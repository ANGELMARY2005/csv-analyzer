<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Data Science Playground</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #f8961e;
            --info: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fb;
            color: var(--dark);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 1.5rem 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            font-size: 2rem;
        }

        .logo h1 {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .tagline {
            font-size: 1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .sidebar {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            height: fit-content;
        }

        .content-area {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            min-height: 80vh;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--light-gray);
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
        }

        .tab:hover:not(.active) {
            background-color: var(--light-gray);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
        }

        .card-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--dark);
        }

        .file-upload-area {
            border: 2px dashed var(--light-gray);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background-color: rgba(67, 97, 238, 0.05);
        }

        .file-upload-area i {
            font-size: 3rem;
            color: var(--gray);
            margin-bottom: 15px;
        }

        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: center;
        }

        .btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }

        .dataset-info {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .info-label {
            font-size: 0.9rem;
            color: var(--gray);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--light-gray);
        }

        th {
            background-color: var(--light);
            font-weight: 600;
        }

        tr:hover {
            background-color: rgba(67, 97, 238, 0.05);
        }

        .chart-container {
            width: 100%;
            height: 400px;
            margin-bottom: 30px;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .chart-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        select,
        input {
            padding: 8px 12px;
            border: 1px solid var(--light-gray);
            border-radius: 5px;
            background-color: white;
        }

        .insight-card {
            background: linear-gradient(135deg, #f5f7ff, #e6eeff);
            border-left: 4px solid var(--info);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            border-top: 3px solid var(--primary);
        }

        .stat-name {
            font-size: 0.9rem;
            color: var(--gray);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--dark);
        }

        .missing-badge {
            display: inline-block;
            padding: 3px 8px;
            background-color: var(--danger);
            color: white;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--light-gray);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary);
        }

        .column-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .type-numeric {
            background-color: rgba(67, 97, 238, 0.1);
            color: var(--primary);
        }

        .type-categorical {
            background-color: rgba(248, 150, 30, 0.1);
            color: var(--warning);
        }

        .type-date {
            background-color: rgba(76, 201, 240, 0.1);
            color: var(--success);
        }

        .type-boolean {
            background-color: rgba(247, 37, 133, 0.1);
            color: var(--danger);
        }

        footer {
            text-align: center;
            padding: 20px 0;
            margin-top: 40px;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid var(--light-gray);
        }

        @media (max-width: 992px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: 2;
            }

            .content-area {
                order: 1;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìä</div>
                    <div>
                        <h1>Data Explorer: Your Browser-Based Analytics Companion</h1>
                        <div class="tagline">Data analytics using your csv file</div>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="btn btn-outline" id="exportBtn">Export Results</button>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="main-content">
            <aside class="sidebar">
                <div class="card">
                    <h3 class="card-title">Upload Dataset</h3>
                    <div class="file-upload-area" id="fileUploadArea">
                        <div>üìÅ</div>
                        <p>Drag & drop your CSV file here</p>
                        <p>or</p>
                        <button class="btn" id="browseBtn">Browse Files</button>
                        <input type="file" id="fileInput" accept=".csv" style="display: none;">
                    </div>
                    <div id="fileInfo" style="display: none;">
                        <p><strong>File:</strong> <span id="fileName"></span></p>
                        <p><strong>Size:</strong> <span id="fileSize"></span></p>
                        <button class="btn" id="analyzeBtn" style="width: 100%; margin-top: 10px;">Analyze
                            Dataset</button>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">Dataset Info</h3>
                    <div id="datasetInfo" style="display: none;">
                        <div class="dataset-info">
                            <div class="info-card">
                                <div class="info-value" id="rowCount">0</div>
                                <div class="info-label">Rows</div>
                            </div>
                            <div class="info-card">
                                <div class="info-value" id="colCount">0</div>
                                <div class="info-label">Columns</div>
                            </div>
                            <div class="info-card">
                                <div class="info-value" id="missingCount">0</div>
                                <div class="info-label">Missing Values</div>
                            </div>
                        </div>
                    </div>
                    <div id="noDatasetInfo">
                        <p>Upload a CSV file to see dataset information</p>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">Quick Actions</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="btn btn-outline" id="detectOutliersBtn">Detect Outliers</button>
                        <button class="btn btn-outline" id="showMissingBtn">Show Missing Values</button>
                        <button class="btn btn-outline" id="generateInsightsBtn">Generate Insights</button>
                    </div>
                </div>
            </aside>

            <main class="content-area">
                <div class="tabs">
                    <div class="tab active" data-tab="overview">Data Overview</div>
                    <div class="tab" data-tab="profiling">Data Profiling</div>
                    <div class="tab" data-tab="visualization">Visualization</div>
                    <div class="tab" data-tab="analytics">Analytics</div>
                    <div class="tab" data-tab="insights">Insights</div>
                </div>

                <div class="tab-content active" id="overview">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Data Preview</h2>
                        </div>
                        <div id="dataPreview">
                            <p>Upload a CSV file to preview the data</p>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Column Information</h2>
                        </div>
                        <div id="columnInfo">
                            <p>Column details will appear here after analysis</p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="profiling">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Statistical Summary</h2>
                        </div>
                        <div id="statSummary">
                            <p>Statistical summary will appear here after analysis</p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="visualization">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Chart Configuration</h2>
                        </div>
                        <div class="chart-controls">
                            <div class="control-group">
                                <label for="chartType">Chart Type</label>
                                <select id="chartType">
                                    <option value="scatter">Scatter Plot</option>
                                    <option value="line">Line Chart</option>
                                    <option value="bar">Bar Chart</option>
                                    <option value="heatmap">Heatmap</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="xAxis">X-Axis</label>
                                <select id="xAxis">
                                    <option value="">Select column</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="yAxis">Y-Axis</label>
                                <select id="yAxis">
                                    <option value="">Select column</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="colorBy">Color By</label>
                                <select id="colorBy">
                                    <option value="">None</option>
                                </select>
                            </div>
                            <div class="control-group" style="align-self: flex-end;">
                                <button class="btn" id="renderChartBtn">Render Chart</button>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Chart Display</h2>
                        </div>
                        <div class="chart-container">
                            <canvas id="chartCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="analytics">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Missing Values Analysis</h2>
                        </div>
                        <div id="missingAnalysis">
                            <p>Missing values analysis will appear here after analysis</p>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Outlier Detection</h2>
                        </div>
                        <div id="outlierAnalysis">
                            <p>Outlier detection results will appear here after analysis</p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="insights">
                    <div class="card insight-card">
                        <div class="card-header">
                            <h2 class="card-title">Automated Insights</h2>
                        </div>
                        <div id="insightsContent">
                            <p>AI-generated insights will appear here after analysis</p>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>Interactive Data Science Playground &copy; 2025 | ANGEL MARY </p>
        </div>
    </footer>

    <script>
        // Global variables
        let dataset = null;
        let columns = [];
        let columnTypes = {};

        // DOM elements
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');
        const browseBtn = document.getElementById('browseBtn');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const datasetInfo = document.getElementById('datasetInfo');
        const noDatasetInfo = document.getElementById('noDatasetInfo');
        const rowCount = document.getElementById('rowCount');
        const colCount = document.getElementById('colCount');
        const missingCount = document.getElementById('missingCount');
        const dataPreview = document.getElementById('dataPreview');
        const columnInfo = document.getElementById('columnInfo');
        const statSummary = document.getElementById('statSummary');
        const missingAnalysis = document.getElementById('missingAnalysis');
        const outlierAnalysis = document.getElementById('outlierAnalysis');
        const insightsContent = document.getElementById('insightsContent');
        const chartType = document.getElementById('chartType');
        const xAxis = document.getElementById('xAxis');
        const yAxis = document.getElementById('yAxis');
        const colorBy = document.getElementById('colorBy');
        const renderChartBtn = document.getElementById('renderChartBtn');
        const chartCanvas = document.getElementById('chartCanvas');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const exportBtn = document.getElementById('exportBtn');
        const detectOutliersBtn = document.getElementById('detectOutliersBtn');
        const showMissingBtn = document.getElementById('showMissingBtn');
        const generateInsightsBtn = document.getElementById('generateInsightsBtn');

        // Event listeners
        browseBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.style.borderColor = 'var(--primary)';
            fileUploadArea.style.backgroundColor = 'rgba(67, 97, 238, 0.05)';
        });
        fileUploadArea.addEventListener('dragleave', () => {
            fileUploadArea.style.borderColor = 'var(--light-gray)';
            fileUploadArea.style.backgroundColor = 'transparent';
        });
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.style.borderColor = 'var(--light-gray)';
            fileUploadArea.style.backgroundColor = 'transparent';

            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        analyzeBtn.addEventListener('click', analyzeDataset);
        renderChartBtn.addEventListener('click', renderChart);
        exportBtn.addEventListener('click', exportResults);
        detectOutliersBtn.addEventListener('click', detectOutliers);
        showMissingBtn.addEventListener('click', showMissingValues);
        generateInsightsBtn.addEventListener('click', generateInsights);

        // Tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');

                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));

                tab.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // File handling
        function handleFileSelect() {
            const file = fileInput.files[0];
            if (!file) return;

            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.style.display = 'block';

            // Read the file
            const reader = new FileReader();
            reader.onload = function (e) {
                const csvData = e.target.result;
                parseCSV(csvData);
            };
            reader.readAsText(file);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function parseCSV(csvData) {
            const lines = csvData.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            dataset = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const values = lines[i].split(',').map(v => v.trim());
                const row = {};

                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });

                dataset.push(row);
            }

            columns = headers;
            updateDatasetInfo();
            showDataPreview();
        }

        function updateDatasetInfo() {
            if (!dataset) return;

            rowCount.textContent = dataset.length;
            colCount.textContent = columns.length;

            // Count missing values
            let missing = 0;
            dataset.forEach(row => {
                columns.forEach(col => {
                    if (row[col] === '' || row[col] === null || row[col] === undefined) {
                        missing++;
                    }
                });
            });

            missingCount.textContent = missing;
            datasetInfo.style.display = 'block';
            noDatasetInfo.style.display = 'none';
        }

        function showDataPreview() {
            if (!dataset) return;

            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            ${columns.map(col => `<th>${col}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Show first 10 rows
            for (let i = 0; i < Math.min(10, dataset.length); i++) {
                tableHTML += '<tr>';
                columns.forEach(col => {
                    tableHTML += `<td>${dataset[i][col]}</td>`;
                });
                tableHTML += '</tr>';
            }

            tableHTML += '</tbody></table>';
            dataPreview.innerHTML = tableHTML;
        }

        function analyzeDataset() {
            if (!dataset) {
                alert('Please upload a CSV file first.');
                return;
            }

            detectColumnTypes();
            showColumnInfo();
            showStatisticalSummary();
            populateChartControls();
            analyzeMissingValues();
            generateInsights();

            // Switch to profiling tab
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="profiling"]').classList.add('active');
            document.getElementById('profiling').classList.add('active');
        }

        function detectColumnTypes() {
            columnTypes = {};

            columns.forEach(col => {
                const values = dataset.map(row => row[col]);
                columnTypes[col] = determineColumnType(values);
            });
        }

        function determineColumnType(values) {
            // Check if all values are empty
            if (values.every(v => v === '')) return 'empty';

            // Check for boolean
            const boolValues = ['true', 'false', 'yes', 'no', '1', '0'];
            if (values.every(v => boolValues.includes(v.toString().toLowerCase()))) return 'boolean';

            // Check for numeric
            let numericCount = 0;
            values.forEach(v => {
                if (v !== '' && !isNaN(parseFloat(v))) numericCount++;
            });

            if (numericCount / values.length > 0.8) return 'numeric';

            // Check for date (simple check)
            let dateCount = 0;
            const datePatterns = [
                /\d{1,2}\/\d{1,2}\/\d{4}/,
                /\d{4}-\d{1,2}-\d{1,2}/,
                /\d{1,2}-\d{1,2}-\d{4}/
            ];

            values.forEach(v => {
                if (v !== '') {
                    for (const pattern of datePatterns) {
                        if (pattern.test(v)) {
                            dateCount++;
                            break;
                        }
                    }
                }
            });

            if (dateCount / values.length > 0.7) return 'date';

            // Default to categorical
            return 'categorical';
        }

        function showColumnInfo() {
            let html = '<table><thead><tr><th>Column</th><th>Type</th><th>Non-Null</th><th>Null</th><th>Unique</th></tr></thead><tbody>';

            columns.forEach(col => {
                const values = dataset.map(row => row[col]);
                const nonNull = values.filter(v => v !== '').length;
                const nullCount = values.length - nonNull;
                const uniqueCount = new Set(values.filter(v => v !== '')).size;

                let typeClass = '';
                switch (columnTypes[col]) {
                    case 'numeric': typeClass = 'type-numeric'; break;
                    case 'categorical': typeClass = 'type-categorical'; break;
                    case 'date': typeClass = 'type-date'; break;
                    case 'boolean': typeClass = 'type-boolean'; break;
                }

                html += `
                    <tr>
                        <td>${col}</td>
                        <td><span class="column-type ${typeClass}">${columnTypes[col]}</span></td>
                        <td>${nonNull}</td>
                        <td>${nullCount > 0 ? `<span class="missing-badge">${nullCount}</span>` : '0'}</td>
                        <td>${uniqueCount}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            columnInfo.innerHTML = html;
        }

        function showStatisticalSummary() {
            let html = '<div class="stat-grid">';

            columns.forEach(col => {
                if (columnTypes[col] === 'numeric') {
                    const stats = calculateNumericStats(col);
                    html += `
                        <div class="stat-card">
                            <h3>${col}</h3>
                            <div class="stat-name">Mean</div>
                            <div class="stat-value">${stats.mean.toFixed(2)}</div>
                            <div class="stat-name">Median</div>
                            <div class="stat-value">${stats.median.toFixed(2)}</div>
                            <div class="stat-name">Std Dev</div>
                            <div class="stat-value">${stats.stdDev.toFixed(2)}</div>
                            <div class="stat-name">Min / Max</div>
                            <div class="stat-value">${stats.min.toFixed(2)} / ${stats.max.toFixed(2)}</div>
                        </div>
                    `;
                } else if (columnTypes[col] === 'categorical') {
                    const stats = calculateCategoricalStats(col);
                    html += `
                        <div class="stat-card">
                            <h3>${col}</h3>
                            <div class="stat-name">Unique Values</div>
                            <div class="stat-value">${stats.unique}</div>
                            <div class="stat-name">Most Frequent</div>
                            <div class="stat-value">${stats.mostFrequent}</div>
                            <div class="stat-name">Frequency</div>
                            <div class="stat-value">${stats.frequency}</div>
                        </div>
                    `;
                }
            });

            html += '</div>';
            statSummary.innerHTML = html;
        }

        function calculateNumericStats(col) {
            const values = dataset
                .map(row => parseFloat(row[col]))
                .filter(v => !isNaN(v));

            if (values.length === 0) return { mean: 0, median: 0, stdDev: 0, min: 0, max: 0 };

            values.sort((a, b) => a - b);

            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const median = values.length % 2 === 0
                ? (values[values.length / 2 - 1] + values[values.length / 2]) / 2
                : values[Math.floor(values.length / 2)];

            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);

            return {
                mean,
                median,
                stdDev,
                min: values[0],
                max: values[values.length - 1]
            };
        }

        function calculateCategoricalStats(col) {
            const values = dataset.map(row => row[col]).filter(v => v !== '');
            const valueCounts = {};

            values.forEach(v => {
                valueCounts[v] = (valueCounts[v] || 0) + 1;
            });

            let mostFrequent = '';
            let maxCount = 0;

            for (const [value, count] of Object.entries(valueCounts)) {
                if (count > maxCount) {
                    mostFrequent = value;
                    maxCount = count;
                }
            }

            return {
                unique: Object.keys(valueCounts).length,
                mostFrequent,
                frequency: maxCount
            };
        }

        function populateChartControls() {
            // Clear existing options
            xAxis.innerHTML = '<option value="">Select column</option>';
            yAxis.innerHTML = '<option value="">Select column</option>';
            colorBy.innerHTML = '<option value="">None</option>';

            // Add columns based on type
            columns.forEach(col => {
                if (columnTypes[col] === 'numeric' || columnTypes[col] === 'date') {
                    const option = `<option value="${col}">${col}</option>`;
                    xAxis.innerHTML += option;
                    yAxis.innerHTML += option;
                }

                if (columnTypes[col] === 'categorical' || columnTypes[col] === 'boolean') {
                    colorBy.innerHTML += `<option value="${col}">${col}</option>`;
                }
            });
        }

        function renderChart() {
            const ctx = chartCanvas.getContext('2d');
            const selectedChartType = chartType.value;
            const xCol = xAxis.value;
            const yCol = yAxis.value;
            const colorCol = colorBy.value;

            if (!xCol || !yCol) {
                alert('Please select both X and Y axes.');
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Set canvas dimensions
            chartCanvas.width = chartCanvas.offsetWidth;
            chartCanvas.height = chartCanvas.offsetHeight;

            // Draw chart based on type
            switch (selectedChartType) {
                case 'scatter':
                    drawScatterPlot(ctx, xCol, yCol, colorCol);
                    break;
                case 'line':
                    drawLineChart(ctx, xCol, yCol);
                    break;
                case 'bar':
                    drawBarChart(ctx, xCol, yCol);
                    break;
                case 'heatmap':
                    drawHeatmap(ctx, xCol, yCol);
                    break;
            }
        }

        function drawScatterPlot(ctx, xCol, yCol, colorCol) {
            const padding = 50;
            const width = chartCanvas.width - padding * 2;
            const height = chartCanvas.height - padding * 2;

            // Get data points
            const points = dataset
                .map(row => ({
                    x: parseFloat(row[xCol]),
                    y: parseFloat(row[yCol]),
                    color: colorCol ? row[colorCol] : null
                }))
                .filter(p => !isNaN(p.x) && !isNaN(p.y));

            if (points.length === 0) {
                ctx.fillText('No valid data points to display', chartCanvas.width / 2, chartCanvas.height / 2);
                return;
            }

            // Calculate scales
            const xValues = points.map(p => p.x);
            const yValues = points.map(p => p.y);

            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xScale = width / (xMax - xMin);
            const yScale = height / (yMax - yMin);

            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw points
            points.forEach(point => {
                const x = padding + (point.x - xMin) * xScale;
                const y = padding + height - (point.y - yMin) * yScale;

                ctx.fillStyle = point.color ? getColorForValue(point.color) : '#4361ee';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xCol, padding + width / 2, padding + height + 30);

            ctx.save();
            ctx.translate(10, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yCol, 0, 0);
            ctx.restore();
        }

        function drawLineChart(ctx, xCol, yCol) {
            const padding = 50;
            const width = chartCanvas.width - padding * 2;
            const height = chartCanvas.height - padding * 2;

            // Get data points
            const points = dataset
                .map(row => ({
                    x: parseFloat(row[xCol]),
                    y: parseFloat(row[yCol])
                }))
                .filter(p => !isNaN(p.x) && !isNaN(p.y))
                .sort((a, b) => a.x - b.x);

            if (points.length === 0) {
                ctx.fillText('No valid data points to display', chartCanvas.width / 2, chartCanvas.height / 2);
                return;
            }

            // Calculate scales
            const xValues = points.map(p => p.x);
            const yValues = points.map(p => p.y);

            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xScale = width / (xMax - xMin);
            const yScale = height / (yMax - yMin);

            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw line
            ctx.strokeStyle = '#4361ee';
            ctx.lineWidth = 2;
            ctx.beginPath();

            points.forEach((point, i) => {
                const x = padding + (point.x - xMin) * xScale;
                const y = padding + height - (point.y - yMin) * yScale;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#4361ee';
            points.forEach(point => {
                const x = padding + (point.x - xMin) * xScale;
                const y = padding + height - (point.y - yMin) * yScale;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xCol, padding + width / 2, padding + height + 30);

            ctx.save();
            ctx.translate(10, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yCol, 0, 0);
            ctx.restore();
        }

        function drawBarChart(ctx, xCol, yCol) {
            const padding = 50;
            const width = chartCanvas.width - padding * 2;
            const height = chartCanvas.height - padding * 2;

            // Group data by xCol and calculate average of yCol
            const groups = {};
            dataset.forEach(row => {
                if (row[xCol] && row[yCol] && !isNaN(parseFloat(row[yCol]))) {
                    if (!groups[row[xCol]]) {
                        groups[row[xCol]] = [];
                    }
                    groups[row[xCol]].push(parseFloat(row[yCol]));
                }
            });

            const groupNames = Object.keys(groups);
            if (groupNames.length === 0) {
                ctx.fillText('No valid data to display', chartCanvas.width / 2, chartCanvas.height / 2);
                return;
            }

            const groupAverages = {};
            groupNames.forEach(name => {
                const values = groups[name];
                groupAverages[name] = values.reduce((a, b) => a + b, 0) / values.length;
            });

            // Calculate scales
            const averages = Object.values(groupAverages);
            const maxValue = Math.max(...averages);
            const barWidth = width / groupNames.length * 0.8;

            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw bars
            ctx.fillStyle = '#4361ee';
            groupNames.forEach((name, i) => {
                const x = padding + i * (width / groupNames.length) + (width / groupNames.length - barWidth) / 2;
                const barHeight = (groupAverages[name] / maxValue) * height;
                const y = padding + height - barHeight;

                ctx.fillRect(x, y, barWidth, barHeight);

                // Draw label
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, x + barWidth / 2, padding + height + 15);
                ctx.fillStyle = '#4361ee';
            });

            // Draw y-axis label
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.save();
            ctx.translate(10, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(`Average ${yCol}`, 0, 0);
            ctx.restore();
        }

        function drawHeatmap(ctx, xCol, yCol) {
            // This is a simplified heatmap showing correlation
            const numericColumns = columns.filter(col => columnTypes[col] === 'numeric');

            if (numericColumns.length < 2) {
                ctx.fillText('Need at least 2 numeric columns for heatmap', chartCanvas.width / 2, chartCanvas.height / 2);
                return;
            }

            const cellSize = 30;
            const padding = 50;

            // Calculate correlations
            const correlations = [];
            for (let i = 0; i < numericColumns.length; i++) {
                correlations[i] = [];
                for (let j = 0; j < numericColumns.length; j++) {
                    if (i === j) {
                        correlations[i][j] = 1;
                    } else {
                        correlations[i][j] = calculateCorrelation(numericColumns[i], numericColumns[j]);
                    }
                }
            }

            // Draw heatmap
            for (let i = 0; i < numericColumns.length; i++) {
                for (let j = 0; j < numericColumns.length; j++) {
                    const x = padding + i * cellSize;
                    const y = padding + j * cellSize;

                    // Color based on correlation value
                    const corr = correlations[i][j];
                    const intensity = Math.abs(corr);
                    let color;

                    if (corr > 0) {
                        color = `rgb(${255 * (1 - intensity)}, ${255 * (1 - intensity)}, 255)`;
                    } else {
                        color = `rgb(255, ${255 * (1 - intensity)}, ${255 * (1 - intensity)})`;
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);

                    // Draw correlation value
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(corr.toFixed(2), x + cellSize / 2, y + cellSize / 2 + 3);
                }

                // Draw column labels
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(numericColumns[i], padding + i * cellSize + cellSize / 2, padding - 10);
                ctx.fillText(numericColumns[i], padding - 10, padding + i * cellSize + cellSize / 2 + 3);
            }
        }

        function calculateCorrelation(col1, col2) {
            const values1 = dataset.map(row => parseFloat(row[col1])).filter(v => !isNaN(v));
            const values2 = dataset.map(row => parseFloat(row[col2])).filter(v => !isNaN(v));

            // Make sure we have matching data points
            const n = Math.min(values1.length, values2.length);
            if (n === 0) return 0;

            const mean1 = values1.slice(0, n).reduce((a, b) => a + b, 0) / n;
            const mean2 = values2.slice(0, n).reduce((a, b) => a + b, 0) / n;

            let numerator = 0;
            let denominator1 = 0;
            let denominator2 = 0;

            for (let i = 0; i < n; i++) {
                numerator += (values1[i] - mean1) * (values2[i] - mean2);
                denominator1 += Math.pow(values1[i] - mean1, 2);
                denominator2 += Math.pow(values2[i] - mean2, 2);
            }

            if (denominator1 === 0 || denominator2 === 0) return 0;

            return numerator / Math.sqrt(denominator1 * denominator2);
        }

        function getColorForValue(value) {
            // Simple hash function to generate consistent colors
            let hash = 0;
            for (let i = 0; i < value.length; i++) {
                hash = value.charCodeAt(i) + ((hash << 5) - hash);
            }

            const hue = hash % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }

        function analyzeMissingValues() {
            let html = '<table><thead><tr><th>Column</th><th>Total Values</th><th>Missing Values</th><th>Missing %</th></tr></thead><tbody>';

            columns.forEach(col => {
                const values = dataset.map(row => row[col]);
                const total = values.length;
                const missing = values.filter(v => v === '').length;
                const missingPercent = (missing / total * 100).toFixed(2);

                html += `
                    <tr>
                        <td>${col}</td>
                        <td>${total}</td>
                        <td>${missing}</td>
                        <td>
                            <div>${missingPercent}%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${missingPercent}%"></div>
                            </div>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            missingAnalysis.innerHTML = html;
        }

        function detectOutliers() {
            if (!dataset) {
                alert('Please upload and analyze a dataset first.');
                return;
            }

            let html = '<h3>Outlier Detection Results</h3>';
            const numericColumns = columns.filter(col => columnTypes[col] === 'numeric');

            if (numericColumns.length === 0) {
                html += '<p>No numeric columns found for outlier detection.</p>';
                outlierAnalysis.innerHTML = html;
                return;
            }

            numericColumns.forEach(col => {
                const values = dataset
                    .map(row => parseFloat(row[col]))
                    .filter(v => !isNaN(v))
                    .sort((a, b) => a - b);

                if (values.length < 4) {
                    html += `<p>Column "${col}" doesn't have enough data for outlier detection.</p>`;
                    return;
                }

                const q1 = values[Math.floor(values.length * 0.25)];
                const q3 = values[Math.floor(values.length * 0.75)];
                const iqr = q3 - q1;
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;

                const outliers = values.filter(v => v < lowerBound || v > upperBound);

                html += `
                    <div class="stat-card" style="margin-bottom: 15px;">
                        <h4>${col}</h4>
                        <div class="stat-name">Outliers</div>
                        <div class="stat-value">${outliers.length}</div>
                        <div class="stat-name">Lower Bound</div>
                        <div class="stat-value">${lowerBound.toFixed(2)}</div>
                        <div class="stat-name">Upper Bound</div>
                        <div class="stat-value">${upperBound.toFixed(2)}</div>
                    </div>
                `;
            });

            outlierAnalysis.innerHTML = html;

            // Switch to analytics tab
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analytics"]').classList.add('active');
            document.getElementById('analytics').classList.add('active');
        }

        function showMissingValues() {
            // Switch to analytics tab and ensure missing values section is visible
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analytics"]').classList.add('active');
            document.getElementById('analytics').classList.add('active');

            // Scroll to missing values section
            document.getElementById('missingAnalysis').scrollIntoView({ behavior: 'smooth' });
        }

        function generateInsights() {
            if (!dataset) {
                insightsContent.innerHTML = '<p>Please upload and analyze a dataset first.</p>';
                return;
            }

            let insights = [];

            // Check for high variance in numeric columns
            columns.forEach(col => {
                if (columnTypes[col] === 'numeric') {
                    const stats = calculateNumericStats(col);
                    if (stats.stdDev / stats.mean > 0.5) {
                        insights.push(`Column <strong>${col}</strong> has high variance (std dev = ${stats.stdDev.toFixed(2)}), indicating diverse values in your dataset.`);
                    }
                }
            });

            // Check for strong correlations
            const numericColumns = columns.filter(col => columnTypes[col] === 'numeric');
            for (let i = 0; i < numericColumns.length; i++) {
                for (let j = i + 1; j < numericColumns.length; j++) {
                    const corr = calculateCorrelation(numericColumns[i], numericColumns[j]);
                    if (Math.abs(corr) > 0.7) {
                        const direction = corr > 0 ? 'positive' : 'negative';
                        insights.push(`Columns <strong>${numericColumns[i]}</strong> and <strong>${numericColumns[j]}</strong> show a strong ${direction} correlation (r = ${corr.toFixed(2)}).`);
                    }
                }
            }

            // Check for missing values
            let totalMissing = 0;
            let totalCells = 0;

            columns.forEach(col => {
                const values = dataset.map(row => row[col]);
                totalCells += values.length;
                totalMissing += values.filter(v => v === '').length;
            });

            const missingPercent = (totalMissing / totalCells * 100).toFixed(2);
            if (missingPercent > 5) {
                insights.push(`Dataset contains <strong>${missingPercent}%</strong> missing values. Consider data cleaning before analysis.`);
            }

            // Check for categorical columns with many unique values
            columns.forEach(col => {
                if (columnTypes[col] === 'categorical') {
                    const values = dataset.map(row => row[col]).filter(v => v !== '');
                    const uniqueCount = new Set(values).size;

                    if (uniqueCount > values.length * 0.5) {
                        insights.push(`Column <strong>${col}</strong> has many unique values (${uniqueCount}), which might make categorical analysis difficult.`);
                    }
                }
            });

            // If no specific insights, provide general ones
            if (insights.length === 0) {
                insights.push(
                    'Your dataset appears to be well-structured with no obvious issues detected.',
                    'Consider exploring relationships between variables using the visualization tools.',
                    'All numeric columns show moderate variance, suggesting balanced distributions.'
                );
            }

            // Format insights as HTML
            let html = '<ul style="list-style-type: none; padding-left: 0;">';
            insights.forEach(insight => {
                html += `<li style="margin-bottom: 15px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: var(--info);">üí°</span>
                    ${insight}
                </li>`;
            });
            html += '</ul>';

            insightsContent.innerHTML = html;

            // Switch to insights tab
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="insights"]').classList.add('active');
            document.getElementById('insights').classList.add('active');
        }

        function exportResults() {
            if (!dataset) {
                alert('Please upload and analyze a dataset first.');
                return;
            }

            // Create a simple report
            let report = `Data Science Playground Analysis Report\n`;
            report += `Generated on: ${new Date().toLocaleString()}\n\n`;

            report += `Dataset Overview:\n`;
            report += `- Rows: ${dataset.length}\n`;
            report += `- Columns: ${columns.length}\n`;

            // Add column information
            report += `\nColumn Information:\n`;
            columns.forEach(col => {
                const values = dataset.map(row => row[col]);
                const nonNull = values.filter(v => v !== '').length;
                const nullCount = values.length - nonNull;
                const uniqueCount = new Set(values.filter(v => v !== '')).size;

                report += `- ${col} (${columnTypes[col]}): ${nonNull} non-null, ${nullCount} null, ${uniqueCount} unique values\n`;
            });

            // Create a Blob and download link
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'data_analysis_report.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize with sample data for demonstration
        function initializeWithSampleData() {
            const sampleCSV = `Age,Income,SpendingScore,Gender,City
25,35000,75,Male,New York
32,45000,60,Female,Chicago
45,75000,90,Male,Los Angeles
28,32000,40,Female,New York
55,100000,95,Male,Chicago
38,60000,70,Female,Los Angeles
22,28000,35,Male,New York
50,85000,85,Female,Chicago
35,55000,65,Male,Los Angeles
42,70000,80,Female,New York`;

            parseCSV(sampleCSV);
            fileName.textContent = 'sample_data.csv';
            fileSize.textContent = '1.2 KB';
            fileInfo.style.display = 'block';
        }

        // Initialize the application
        window.addEventListener('DOMContentLoaded', () => {
            initializeWithSampleData();
        });
    </script>
</body>

</html>
